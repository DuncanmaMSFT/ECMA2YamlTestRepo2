### YamlMime:ManagedReference
items:
- uid: System.Func`1
  id: Func`1
  langs:
  - csharp
  name: Func<TResult>
  nameWithType: Func<TResult>
  fullName: System.Func<TResult>
  type: Delegate
  summary: Encapsulates a method that has no parameters and returns a value of the type specified by the <code>TResult</code> parameter.
  remarks: "You can use this delegate to represent a method that can be passed as a parameter without explicitly declaring a custom delegate. The encapsulated method must correspond to the method signature that is defined by this delegate. This means that the encapsulated method must have no parameters and must return a value.  \n  \n> [!NOTE]\n>  To reference a method that has no parameters and returns `void` (or in Visual Basic, that is declared as a `Sub` rather than as a `Function`), use the <xref:System.Action> delegate instead.  \n  \n When you use the Func(TResult) delegate, you do not have to explicitly define a delegate that encapsulates a parameterless method. For example, the following code explicitly declares a delegate named `WriteMethod` and assigns a reference to the `OutputTarget.SendToFile` instance method to its delegate instance.  \n  \n [!code-cs[System.Func~1#1](~/add/codesnippet/csharp/t-system.func`1_1.cs)]\n [!code-vb[System.Func~1#1](~/add/codesnippet/visualbasic/t-system.func`1_1.vb)]  \n  \n The following example simplifies this code by instantiating the Func(TResult) delegate instead of explicitly defining a new delegate and assigning a named method to it.  \n  \n [!code-cs[System.Func~1#2](~/add/codesnippet/csharp/t-system.func`1_2.cs)]\n [!code-vb[System.Func~1#2](~/add/codesnippet/visualbasic/t-system.func`1_2.vb)]  \n  \n You can use the Func(TResult) delegate with anonymous methods in C#, as the following example illustrates. (For an introduction to anonymous methods, see [Anonymous Methods](../Topic/Anonymous%20Methods%20\\(C%23%20Programming%20Guide\\).md).)  \n  \n [!code-cs[System.Func~1#3](~/add/codesnippet/csharp/t-system.func`1_3.cs)]  \n  \n You can also assign a lambda expression to a <xref:System.Func%602> delegate, as the following example illustrates. (For an introduction to lambda expressions, see [Lambda Expressions](../Topic/Lambda%20Expressions%20\\(Visual%20Basic\\).md) and [Lambda Expressions](../Topic/Lambda%20Expressions%20\\(C%23%20Programming%20Guide\\).md).)  \n  \n [!code-cs[System.Func~1#4](~/add/codesnippet/csharp/t-system.func`1_4.cs)]\n [!code-vb[System.Func~1#4](~/add/codesnippet/visualbasic/t-system.func`1_4.vb)]  \n  \n The underlying type of a lambda expression is one of the generic `Func` delegates. This makes it possible to pass a lambda expression as a parameter without explicitly assigning it to a delegate. In particular, because many methods of types in the <xref:System.Linq> namespace have `Func` parameters, you can pass these methods a lambda expression without explicitly instantiating a `Func` delegate.  \n  \n If you have an expensive computation that you want to execute only if the result is actually needed, you can assign the expensive function to a Func(TResult) delegate. The execution of the function can then be delayed until a property that accesses the value is used in an expression. The example in the next section demonstrates how to do this."
  example:
  - "The following example demonstrates how to use a delegate that takes no parameters. This code creates a generic class named `LazyValue` that has a field of type Func(TResult). This delegate field can store a reference to any function that returns a value of the type that corresponds to the type parameter of the `LazyValue` object. The `LazyValue` type also has a `Value` property that executes the function (if it has not already been executed) and returns the resulting value.  \n  \n The example creates two methods and instantiates two `LazyValue` objects with lambda expressions that call these methods. The lambda expressions do not take parameters because they just need to call a method. As the output shows, the two methods are executed only when the value of each `LazyValue` object is retrieved.  \n  \n [!code-cs[System.Func~1#5](~/add/codesnippet/csharp/t-system.func`1_5.cs)]\n [!code-vb[System.Func~1#5](~/add/codesnippet/visualbasic/t-system.func`1_5.vb)]"
  syntax:
    content: >-
      [System.Runtime.CompilerServices.TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")]

      public delegate TResult Func<out TResult>();
    typeParameters:
    - id: TResult
      description: The type of the return value of the method that this delegate encapsulates.
  inheritance:
  - System.Object
  - System.Delegate
  original_ecmaxml_local_path: E:\mdoc\ECMA2YamlTestRepo2\fulldocset\xml\System\Func`1.xml
  content_git_url: https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/masterwithyml/fulldocset/xml/System/Func`1.xml
  version:
  - netframework-3.5-client
  - netframework-3.5
  - netframework-4.0-client
  - netframework-4.0
  - netframework-4.5.1
  - netframework-4.5.2
  - netframework-4.5
  - netframework-4.6.1
  - netframework-4.6.2
  - netframework-4.6
references:
- uid: System.Delegate
  isExternal: false
  name: System.Delegate
